/* LCM type definition class file
 * This file was automatically generated by lcm-gen
 * DO NOT MODIFY BY HAND!!!!
 */

package perllcm;
 
import java.io.*;
import java.nio.*;
import java.util.*;
import lcm.lcm.*;
 
public final class van_scene_prior_t implements lcm.lcm.LCMEncodable
{
    public boolean locally_planar;
    public float lp_absdev;
    public double lp_coeff[];
    public float Zmean;
    public float Zstd;
    public float Zabsdev;
    public float Zmin;
    public float Z10;
    public float Z20;
    public float Z30;
    public float Z40;
    public float Z50;
    public float Z60;
    public float Z70;
    public float Z80;
    public float Z90;
    public float Zmax;
    public int npts;
    public short id[];
    public float X[];
    public float Y[];
    public float Z[];
    public float u[];
    public float v[];
 
    public van_scene_prior_t()
    {
        lp_coeff = new double[4];
    }
 
    public static final long LCM_FINGERPRINT;
    public static final long LCM_FINGERPRINT_BASE = 0x156ab3f1dcec041fL;
 
    static {
        LCM_FINGERPRINT = _hashRecursive(new ArrayList<Class>());
    }
 
    public static long _hashRecursive(ArrayList<Class> classes)
    {
        if (classes.contains(perllcm.van_scene_prior_t.class))
            return 0L;
 
        classes.add(perllcm.van_scene_prior_t.class);
        long hash = LCM_FINGERPRINT_BASE
            ;
        classes.remove(classes.size() - 1);
        return (hash<<1) + ((hash>>63)&1);
    }
 
    public void encode(DataOutput outs) throws IOException
    {
        outs.writeLong(LCM_FINGERPRINT);
        _encodeRecursive(outs);
    }
 
    public void _encodeRecursive(DataOutput outs) throws IOException
    {
        outs.writeByte( this.locally_planar ? 1 : 0); 
 
        outs.writeFloat(this.lp_absdev); 
 
        for (int a = 0; a < 4; a++) {
            outs.writeDouble(this.lp_coeff[a]); 
        }
 
        outs.writeFloat(this.Zmean); 
 
        outs.writeFloat(this.Zstd); 
 
        outs.writeFloat(this.Zabsdev); 
 
        outs.writeFloat(this.Zmin); 
 
        outs.writeFloat(this.Z10); 
 
        outs.writeFloat(this.Z20); 
 
        outs.writeFloat(this.Z30); 
 
        outs.writeFloat(this.Z40); 
 
        outs.writeFloat(this.Z50); 
 
        outs.writeFloat(this.Z60); 
 
        outs.writeFloat(this.Z70); 
 
        outs.writeFloat(this.Z80); 
 
        outs.writeFloat(this.Z90); 
 
        outs.writeFloat(this.Zmax); 
 
        outs.writeInt(this.npts); 
 
        for (int a = 0; a < this.npts; a++) {
            outs.writeShort(this.id[a]); 
        }
 
        for (int a = 0; a < this.npts; a++) {
            outs.writeFloat(this.X[a]); 
        }
 
        for (int a = 0; a < this.npts; a++) {
            outs.writeFloat(this.Y[a]); 
        }
 
        for (int a = 0; a < this.npts; a++) {
            outs.writeFloat(this.Z[a]); 
        }
 
        for (int a = 0; a < this.npts; a++) {
            outs.writeFloat(this.u[a]); 
        }
 
        for (int a = 0; a < this.npts; a++) {
            outs.writeFloat(this.v[a]); 
        }
 
    }
 
    public van_scene_prior_t(byte[] data) throws IOException
    {
        this(new LCMDataInputStream(data));
    }
 
    public van_scene_prior_t(DataInput ins) throws IOException
    {
        if (ins.readLong() != LCM_FINGERPRINT)
            throw new IOException("LCM Decode error: bad fingerprint");
 
        _decodeRecursive(ins);
    }
 
    public static perllcm.van_scene_prior_t _decodeRecursiveFactory(DataInput ins) throws IOException
    {
        perllcm.van_scene_prior_t o = new perllcm.van_scene_prior_t();
        o._decodeRecursive(ins);
        return o;
    }
 
    public void _decodeRecursive(DataInput ins) throws IOException
    {
        this.locally_planar = ins.readByte()!=0;
 
        this.lp_absdev = ins.readFloat();
 
        this.lp_coeff = new double[(int) 4];
        for (int a = 0; a < 4; a++) {
            this.lp_coeff[a] = ins.readDouble();
        }
 
        this.Zmean = ins.readFloat();
 
        this.Zstd = ins.readFloat();
 
        this.Zabsdev = ins.readFloat();
 
        this.Zmin = ins.readFloat();
 
        this.Z10 = ins.readFloat();
 
        this.Z20 = ins.readFloat();
 
        this.Z30 = ins.readFloat();
 
        this.Z40 = ins.readFloat();
 
        this.Z50 = ins.readFloat();
 
        this.Z60 = ins.readFloat();
 
        this.Z70 = ins.readFloat();
 
        this.Z80 = ins.readFloat();
 
        this.Z90 = ins.readFloat();
 
        this.Zmax = ins.readFloat();
 
        this.npts = ins.readInt();
 
        this.id = new short[(int) npts];
        for (int a = 0; a < this.npts; a++) {
            this.id[a] = ins.readShort();
        }
 
        this.X = new float[(int) npts];
        for (int a = 0; a < this.npts; a++) {
            this.X[a] = ins.readFloat();
        }
 
        this.Y = new float[(int) npts];
        for (int a = 0; a < this.npts; a++) {
            this.Y[a] = ins.readFloat();
        }
 
        this.Z = new float[(int) npts];
        for (int a = 0; a < this.npts; a++) {
            this.Z[a] = ins.readFloat();
        }
 
        this.u = new float[(int) npts];
        for (int a = 0; a < this.npts; a++) {
            this.u[a] = ins.readFloat();
        }
 
        this.v = new float[(int) npts];
        for (int a = 0; a < this.npts; a++) {
            this.v[a] = ins.readFloat();
        }
 
    }
 
    public perllcm.van_scene_prior_t copy()
    {
        perllcm.van_scene_prior_t outobj = new perllcm.van_scene_prior_t();
        outobj.locally_planar = this.locally_planar;
 
        outobj.lp_absdev = this.lp_absdev;
 
        outobj.lp_coeff = new double[(int) 4];
        System.arraycopy(this.lp_coeff, 0, outobj.lp_coeff, 0, 4); 
        outobj.Zmean = this.Zmean;
 
        outobj.Zstd = this.Zstd;
 
        outobj.Zabsdev = this.Zabsdev;
 
        outobj.Zmin = this.Zmin;
 
        outobj.Z10 = this.Z10;
 
        outobj.Z20 = this.Z20;
 
        outobj.Z30 = this.Z30;
 
        outobj.Z40 = this.Z40;
 
        outobj.Z50 = this.Z50;
 
        outobj.Z60 = this.Z60;
 
        outobj.Z70 = this.Z70;
 
        outobj.Z80 = this.Z80;
 
        outobj.Z90 = this.Z90;
 
        outobj.Zmax = this.Zmax;
 
        outobj.npts = this.npts;
 
        outobj.id = new short[(int) npts];
        if (this.npts > 0)
            System.arraycopy(this.id, 0, outobj.id, 0, this.npts); 
        outobj.X = new float[(int) npts];
        if (this.npts > 0)
            System.arraycopy(this.X, 0, outobj.X, 0, this.npts); 
        outobj.Y = new float[(int) npts];
        if (this.npts > 0)
            System.arraycopy(this.Y, 0, outobj.Y, 0, this.npts); 
        outobj.Z = new float[(int) npts];
        if (this.npts > 0)
            System.arraycopy(this.Z, 0, outobj.Z, 0, this.npts); 
        outobj.u = new float[(int) npts];
        if (this.npts > 0)
            System.arraycopy(this.u, 0, outobj.u, 0, this.npts); 
        outobj.v = new float[(int) npts];
        if (this.npts > 0)
            System.arraycopy(this.v, 0, outobj.v, 0, this.npts); 
        return outobj;
    }
 
}

